// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlist_tracks.sql

package db

import (
	"context"
)

const addPlaylistTrack = `-- name: AddPlaylistTrack :one
INSERT INTO playlist_tracks (playlist_id, track_id, position)
VALUES (?, ?, ?)
ON CONFLICT(playlist_id, track_id) DO UPDATE SET
  position = excluded.position,
  deleted_at = NULL
RETURNING id, playlist_id, track_id, position, deleted_at, created_at, updated_at
`

type AddPlaylistTrackParams struct {
	PlaylistID int64
	TrackID    int64
	Position   int64
}

// Add playlist track (upsert by playlist+track)
func (q *Queries) AddPlaylistTrack(ctx context.Context, arg AddPlaylistTrackParams) (PlaylistTrack, error) {
	row := q.db.QueryRowContext(ctx, addPlaylistTrack, arg.PlaylistID, arg.TrackID, arg.Position)
	var i PlaylistTrack
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.TrackID,
		&i.Position,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const clearPlaylistTracks = `-- name: ClearPlaylistTracks :exec
UPDATE playlist_tracks
SET deleted_at = CURRENT_TIMESTAMP
WHERE playlist_id = ?
  AND deleted_at IS NULL
`

// Clear all tracks from playlist
func (q *Queries) ClearPlaylistTracks(ctx context.Context, playlistID int64) error {
	_, err := q.db.ExecContext(ctx, clearPlaylistTracks, playlistID)
	return err
}

const countPlaylistTracks = `-- name: CountPlaylistTracks :one
SELECT COUNT(*)
FROM playlist_tracks
WHERE playlist_id = ?
  AND deleted_at IS NULL
`

// Count playlist tracks
func (q *Queries) CountPlaylistTracks(ctx context.Context, playlistID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPlaylistTracks, playlistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deletePlaylistTrack = `-- name: DeletePlaylistTrack :execrows
UPDATE playlist_tracks
SET deleted_at = CURRENT_TIMESTAMP
WHERE playlist_id = ?
  AND track_id = ?
  AND deleted_at IS NULL
`

type DeletePlaylistTrackParams struct {
	PlaylistID int64
	TrackID    int64
}

// Delete a track from playlist
func (q *Queries) DeletePlaylistTrack(ctx context.Context, arg DeletePlaylistTrackParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePlaylistTrack, arg.PlaylistID, arg.TrackID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getPlaylistTrack = `-- name: GetPlaylistTrack :one
SELECT id, playlist_id, track_id, position, deleted_at, created_at, updated_at
FROM playlist_tracks
WHERE playlist_id = ?
  AND track_id = ?
  AND deleted_at IS NULL
`

type GetPlaylistTrackParams struct {
	PlaylistID int64
	TrackID    int64
}

// Get playlist track by playlist+track
func (q *Queries) GetPlaylistTrack(ctx context.Context, arg GetPlaylistTrackParams) (PlaylistTrack, error) {
	row := q.db.QueryRowContext(ctx, getPlaylistTrack, arg.PlaylistID, arg.TrackID)
	var i PlaylistTrack
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.TrackID,
		&i.Position,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPlaylistTrackIDs = `-- name: ListPlaylistTrackIDs :many
SELECT track_id
FROM playlist_tracks
WHERE playlist_id = ?
  AND deleted_at IS NULL
ORDER BY position, id
`

// List playlist track IDs in position order
func (q *Queries) ListPlaylistTrackIDs(ctx context.Context, playlistID int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylistTrackIDs, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var track_id int64
		if err := rows.Scan(&track_id); err != nil {
			return nil, err
		}
		items = append(items, track_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlaylistTracks = `-- name: ListPlaylistTracks :many
SELECT
  pt.id, pt.playlist_id, pt.track_id, pt.position, pt.deleted_at, pt.created_at, pt.updated_at,
  t.id, t.folder_id, t.artist_id, t.album_id, t.rel_path, t.title, t.filename, t.ext, t.genre, t.year, t.rating, t.image_path, t.size_bytes, t.last_modified, t.duration_seconds, t.last_seen_at, t.deleted_at, t.created_at, t.updated_at,
  ar.id, ar.name, ar.deleted_at, ar.created_at, ar.updated_at,
  al.id, al.artist_id, al.title, al.image_path, al.deleted_at, al.created_at, al.updated_at,
  al_ar.id, al_ar.name, al_ar.deleted_at, al_ar.created_at, al_ar.updated_at
FROM playlist_tracks pt
JOIN tracks t ON t.id = pt.track_id
LEFT JOIN artists ar ON ar.id = t.artist_id
LEFT JOIN albums al ON al.id = t.album_id
LEFT JOIN artists al_ar ON al_ar.id = al.artist_id
WHERE pt.playlist_id = ?
  AND pt.deleted_at IS NULL
  AND t.deleted_at IS NULL
ORDER BY pt.position
`

type ListPlaylistTracksRow struct {
	PlaylistTrack PlaylistTrack
	Track         Track
	Artist        Artist
	Album         Album
	Artist_2      Artist
}

// List playlist tracks with track metadata
func (q *Queries) ListPlaylistTracks(ctx context.Context, playlistID int64) ([]ListPlaylistTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPlaylistTracksRow
	for rows.Next() {
		var i ListPlaylistTracksRow
		if err := rows.Scan(
			&i.PlaylistTrack.ID,
			&i.PlaylistTrack.PlaylistID,
			&i.PlaylistTrack.TrackID,
			&i.PlaylistTrack.Position,
			&i.PlaylistTrack.DeletedAt,
			&i.PlaylistTrack.CreatedAt,
			&i.PlaylistTrack.UpdatedAt,
			&i.Track.ID,
			&i.Track.FolderID,
			&i.Track.ArtistID,
			&i.Track.AlbumID,
			&i.Track.RelPath,
			&i.Track.Title,
			&i.Track.Filename,
			&i.Track.Ext,
			&i.Track.Genre,
			&i.Track.Year,
			&i.Track.Rating,
			&i.Track.ImagePath,
			&i.Track.SizeBytes,
			&i.Track.LastModified,
			&i.Track.DurationSeconds,
			&i.Track.LastSeenAt,
			&i.Track.DeletedAt,
			&i.Track.CreatedAt,
			&i.Track.UpdatedAt,
			&i.Artist.ID,
			&i.Artist.Name,
			&i.Artist.DeletedAt,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
			&i.Album.ID,
			&i.Album.ArtistID,
			&i.Album.Title,
			&i.Album.ImagePath,
			&i.Album.DeletedAt,
			&i.Album.CreatedAt,
			&i.Album.UpdatedAt,
			&i.Artist_2.ID,
			&i.Artist_2.Name,
			&i.Artist_2.DeletedAt,
			&i.Artist_2.CreatedAt,
			&i.Artist_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPlaylistPosition = `-- name: NextPlaylistPosition :one
SELECT COALESCE(MAX(position), -1) + 1
FROM playlist_tracks
WHERE playlist_id = ?
  AND deleted_at IS NULL
`

// Next position for playlist
func (q *Queries) NextPlaylistPosition(ctx context.Context, playlistID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, nextPlaylistPosition, playlistID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const shiftPlaylistTrackPositionsDownRange = `-- name: ShiftPlaylistTrackPositionsDownRange :exec
UPDATE playlist_tracks
SET position = position - 1
WHERE playlist_id = ?
  AND deleted_at IS NULL
  AND position > ?
  AND position <= ?
`

type ShiftPlaylistTrackPositionsDownRangeParams struct {
	PlaylistID int64
	Position   int64
	Position_2 int64
}

// Shift playlist track positions down within a range (exclusive/inclusive)
func (q *Queries) ShiftPlaylistTrackPositionsDownRange(ctx context.Context, arg ShiftPlaylistTrackPositionsDownRangeParams) error {
	_, err := q.db.ExecContext(ctx, shiftPlaylistTrackPositionsDownRange, arg.PlaylistID, arg.Position, arg.Position_2)
	return err
}

const shiftPlaylistTrackPositionsUpFrom = `-- name: ShiftPlaylistTrackPositionsUpFrom :exec
UPDATE playlist_tracks
SET position = position + 1
WHERE playlist_id = ?
  AND deleted_at IS NULL
  AND position >= ?
`

type ShiftPlaylistTrackPositionsUpFromParams struct {
	PlaylistID int64
	Position   int64
}

// Shift playlist track positions up from a position (inclusive)
func (q *Queries) ShiftPlaylistTrackPositionsUpFrom(ctx context.Context, arg ShiftPlaylistTrackPositionsUpFromParams) error {
	_, err := q.db.ExecContext(ctx, shiftPlaylistTrackPositionsUpFrom, arg.PlaylistID, arg.Position)
	return err
}

const shiftPlaylistTrackPositionsUpRange = `-- name: ShiftPlaylistTrackPositionsUpRange :exec
UPDATE playlist_tracks
SET position = position + 1
WHERE playlist_id = ?
  AND deleted_at IS NULL
  AND position >= ?
  AND position < ?
`

type ShiftPlaylistTrackPositionsUpRangeParams struct {
	PlaylistID int64
	Position   int64
	Position_2 int64
}

// Shift playlist track positions up within a range (inclusive/exclusive)
func (q *Queries) ShiftPlaylistTrackPositionsUpRange(ctx context.Context, arg ShiftPlaylistTrackPositionsUpRangeParams) error {
	_, err := q.db.ExecContext(ctx, shiftPlaylistTrackPositionsUpRange, arg.PlaylistID, arg.Position, arg.Position_2)
	return err
}

const updatePlaylistTrackPosition = `-- name: UpdatePlaylistTrackPosition :one
UPDATE playlist_tracks
SET position = ?
WHERE playlist_id = ?
  AND track_id = ?
  AND deleted_at IS NULL
RETURNING id, playlist_id, track_id, position, deleted_at, created_at, updated_at
`

type UpdatePlaylistTrackPositionParams struct {
	Position   int64
	PlaylistID int64
	TrackID    int64
}

// Update playlist track position
func (q *Queries) UpdatePlaylistTrackPosition(ctx context.Context, arg UpdatePlaylistTrackPositionParams) (PlaylistTrack, error) {
	row := q.db.QueryRowContext(ctx, updatePlaylistTrackPosition, arg.Position, arg.PlaylistID, arg.TrackID)
	var i PlaylistTrack
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.TrackID,
		&i.Position,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlaylistTrackPositionNoReturn = `-- name: UpdatePlaylistTrackPositionNoReturn :exec
UPDATE playlist_tracks
SET position = ?
WHERE playlist_id = ?
  AND track_id = ?
  AND deleted_at IS NULL
`

type UpdatePlaylistTrackPositionNoReturnParams struct {
	Position   int64
	PlaylistID int64
	TrackID    int64
}

// Update playlist track position without returning row
func (q *Queries) UpdatePlaylistTrackPositionNoReturn(ctx context.Context, arg UpdatePlaylistTrackPositionNoReturnParams) error {
	_, err := q.db.ExecContext(ctx, updatePlaylistTrackPositionNoReturn, arg.Position, arg.PlaylistID, arg.TrackID)
	return err
}
