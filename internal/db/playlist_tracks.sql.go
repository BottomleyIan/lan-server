// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlist_tracks.sql

package db

import (
	"context"
)

const addPlaylistTrack = `-- name: AddPlaylistTrack :one
INSERT INTO playlist_tracks (playlist_id, track_id, position)
VALUES (?, ?, ?)
ON CONFLICT(playlist_id, track_id) DO UPDATE SET
  position = excluded.position,
  deleted_at = NULL
RETURNING id, playlist_id, track_id, position, deleted_at, created_at, updated_at
`

type AddPlaylistTrackParams struct {
	PlaylistID int64
	TrackID    int64
	Position   int64
}

// Add playlist track (upsert by playlist+track)
func (q *Queries) AddPlaylistTrack(ctx context.Context, arg AddPlaylistTrackParams) (PlaylistTrack, error) {
	row := q.db.QueryRowContext(ctx, addPlaylistTrack, arg.PlaylistID, arg.TrackID, arg.Position)
	var i PlaylistTrack
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.TrackID,
		&i.Position,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const clearPlaylistTracks = `-- name: ClearPlaylistTracks :exec
UPDATE playlist_tracks
SET deleted_at = CURRENT_TIMESTAMP
WHERE playlist_id = ?
  AND deleted_at IS NULL
`

// Clear all tracks from playlist
func (q *Queries) ClearPlaylistTracks(ctx context.Context, playlistID int64) error {
	_, err := q.db.ExecContext(ctx, clearPlaylistTracks, playlistID)
	return err
}

const deletePlaylistTrack = `-- name: DeletePlaylistTrack :execrows
UPDATE playlist_tracks
SET deleted_at = CURRENT_TIMESTAMP
WHERE playlist_id = ?
  AND track_id = ?
  AND deleted_at IS NULL
`

type DeletePlaylistTrackParams struct {
	PlaylistID int64
	TrackID    int64
}

// Delete a track from playlist
func (q *Queries) DeletePlaylistTrack(ctx context.Context, arg DeletePlaylistTrackParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deletePlaylistTrack, arg.PlaylistID, arg.TrackID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listPlaylistTracks = `-- name: ListPlaylistTracks :many
SELECT
  pt.id, pt.playlist_id, pt.track_id, pt.position, pt.deleted_at, pt.created_at, pt.updated_at,
  t.id, t.folder_id, t.artist_id, t.album_id, t.rel_path, t.title, t.filename, t.ext, t.genre, t.year, t.rating, t.image_path, t.size_bytes, t.last_modified, t.duration_seconds, t.last_seen_at, t.deleted_at, t.created_at, t.updated_at,
  ar.id, ar.name, ar.deleted_at, ar.created_at, ar.updated_at,
  al.id, al.artist_id, al.title, al.image_path, al.deleted_at, al.created_at, al.updated_at,
  al_ar.id, al_ar.name, al_ar.deleted_at, al_ar.created_at, al_ar.updated_at
FROM playlist_tracks pt
JOIN tracks t ON t.id = pt.track_id
LEFT JOIN artists ar ON ar.id = t.artist_id
LEFT JOIN albums al ON al.id = t.album_id
LEFT JOIN artists al_ar ON al_ar.id = al.artist_id
WHERE pt.playlist_id = ?
  AND pt.deleted_at IS NULL
  AND t.deleted_at IS NULL
ORDER BY pt.position
`

type ListPlaylistTracksRow struct {
	PlaylistTrack PlaylistTrack
	Track         Track
	Artist        Artist
	Album         Album
	Artist_2      Artist
}

// List playlist tracks with track metadata
func (q *Queries) ListPlaylistTracks(ctx context.Context, playlistID int64) ([]ListPlaylistTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, listPlaylistTracks, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPlaylistTracksRow
	for rows.Next() {
		var i ListPlaylistTracksRow
		if err := rows.Scan(
			&i.PlaylistTrack.ID,
			&i.PlaylistTrack.PlaylistID,
			&i.PlaylistTrack.TrackID,
			&i.PlaylistTrack.Position,
			&i.PlaylistTrack.DeletedAt,
			&i.PlaylistTrack.CreatedAt,
			&i.PlaylistTrack.UpdatedAt,
			&i.Track.ID,
			&i.Track.FolderID,
			&i.Track.ArtistID,
			&i.Track.AlbumID,
			&i.Track.RelPath,
			&i.Track.Title,
			&i.Track.Filename,
			&i.Track.Ext,
			&i.Track.Genre,
			&i.Track.Year,
			&i.Track.Rating,
			&i.Track.ImagePath,
			&i.Track.SizeBytes,
			&i.Track.LastModified,
			&i.Track.DurationSeconds,
			&i.Track.LastSeenAt,
			&i.Track.DeletedAt,
			&i.Track.CreatedAt,
			&i.Track.UpdatedAt,
			&i.Artist.ID,
			&i.Artist.Name,
			&i.Artist.DeletedAt,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
			&i.Album.ID,
			&i.Album.ArtistID,
			&i.Album.Title,
			&i.Album.ImagePath,
			&i.Album.DeletedAt,
			&i.Album.CreatedAt,
			&i.Album.UpdatedAt,
			&i.Artist_2.ID,
			&i.Artist_2.Name,
			&i.Artist_2.DeletedAt,
			&i.Artist_2.CreatedAt,
			&i.Artist_2.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPlaylistPosition = `-- name: NextPlaylistPosition :one
SELECT COALESCE(MAX(position), 0) + 1
FROM playlist_tracks
WHERE playlist_id = ?
  AND deleted_at IS NULL
`

// Next position for playlist
func (q *Queries) NextPlaylistPosition(ctx context.Context, playlistID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, nextPlaylistPosition, playlistID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updatePlaylistTrackPosition = `-- name: UpdatePlaylistTrackPosition :one
UPDATE playlist_tracks
SET position = ?
WHERE id = ?
  AND playlist_id = ?
  AND deleted_at IS NULL
RETURNING id, playlist_id, track_id, position, deleted_at, created_at, updated_at
`

type UpdatePlaylistTrackPositionParams struct {
	Position   int64
	ID         int64
	PlaylistID int64
}

// Update playlist track position
func (q *Queries) UpdatePlaylistTrackPosition(ctx context.Context, arg UpdatePlaylistTrackPositionParams) (PlaylistTrack, error) {
	row := q.db.QueryRowContext(ctx, updatePlaylistTrackPosition, arg.Position, arg.ID, arg.PlaylistID)
	var i PlaylistTrack
	err := row.Scan(
		&i.ID,
		&i.PlaylistID,
		&i.TrackID,
		&i.Position,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
