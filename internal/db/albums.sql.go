// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: albums.sql

package db

import (
	"context"

	dbtypes "bottomley.ian/musicserver/internal/dbtypes"
)

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT id, artist_id, title, image_path, deleted_at, created_at, updated_at
FROM albums
WHERE id = ?
  AND deleted_at IS NULL
`

// Get a single album by ID (excluding soft-deleted)
func (q *Queries) GetAlbumByID(ctx context.Context, id int64) (Album, error) {
	row := q.db.QueryRowContext(ctx, getAlbumByID, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAlbumWithArtist = `-- name: GetAlbumWithArtist :one
SELECT
  a.id, a.artist_id, a.title, a.image_path, a.deleted_at, a.created_at, a.updated_at,
  ar.id, ar.name, ar.deleted_at, ar.created_at, ar.updated_at
FROM albums a
LEFT JOIN artists ar ON ar.id = a.artist_id
WHERE a.id = ?
  AND a.deleted_at IS NULL
`

type GetAlbumWithArtistRow struct {
	Album  Album
	Artist Artist
}

// Get a single album by ID with artist info
func (q *Queries) GetAlbumWithArtist(ctx context.Context, id int64) (GetAlbumWithArtistRow, error) {
	row := q.db.QueryRowContext(ctx, getAlbumWithArtist, id)
	var i GetAlbumWithArtistRow
	err := row.Scan(
		&i.Album.ID,
		&i.Album.ArtistID,
		&i.Album.Title,
		&i.Album.ImagePath,
		&i.Album.DeletedAt,
		&i.Album.CreatedAt,
		&i.Album.UpdatedAt,
		&i.Artist.ID,
		&i.Artist.Name,
		&i.Artist.DeletedAt,
		&i.Artist.CreatedAt,
		&i.Artist.UpdatedAt,
	)
	return i, err
}

const listAlbums = `-- name: ListAlbums :many
SELECT id, artist_id, title, image_path, deleted_at, created_at, updated_at
FROM albums
WHERE deleted_at IS NULL
  AND (?1 IS NULL OR LOWER(title) LIKE (LOWER(?1) || '%'))
ORDER BY title
`

// List albums
func (q *Queries) ListAlbums(ctx context.Context, dollar_1 interface{}) ([]Album, error) {
	rows, err := q.db.QueryContext(ctx, listAlbums, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.ArtistID,
			&i.Title,
			&i.ImagePath,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAlbumsWithArtist = `-- name: ListAlbumsWithArtist :many
SELECT
  a.id, a.artist_id, a.title, a.image_path, a.deleted_at, a.created_at, a.updated_at,
  ar.id, ar.name, ar.deleted_at, ar.created_at, ar.updated_at
FROM albums a
LEFT JOIN artists ar ON ar.id = a.artist_id
WHERE a.deleted_at IS NULL
  AND (?1 IS NULL OR LOWER(a.title) LIKE (LOWER(?1) || '%'))
ORDER BY a.title
`

type ListAlbumsWithArtistRow struct {
	Album  Album
	Artist Artist
}

// List albums with artist info
func (q *Queries) ListAlbumsWithArtist(ctx context.Context, dollar_1 interface{}) ([]ListAlbumsWithArtistRow, error) {
	rows, err := q.db.QueryContext(ctx, listAlbumsWithArtist, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAlbumsWithArtistRow
	for rows.Next() {
		var i ListAlbumsWithArtistRow
		if err := rows.Scan(
			&i.Album.ID,
			&i.Album.ArtistID,
			&i.Album.Title,
			&i.Album.ImagePath,
			&i.Album.DeletedAt,
			&i.Album.CreatedAt,
			&i.Album.UpdatedAt,
			&i.Artist.ID,
			&i.Artist.Name,
			&i.Artist.DeletedAt,
			&i.Artist.CreatedAt,
			&i.Artist.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAlbum = `-- name: SoftDeleteAlbum :one
UPDATE albums
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

// Soft delete album
func (q *Queries) SoftDeleteAlbum(ctx context.Context, id int64) (Album, error) {
	row := q.db.QueryRowContext(ctx, softDeleteAlbum, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE albums
SET artist_id = ?, title = ?
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpdateAlbumParams struct {
	ArtistID int64
	Title    string
	ID       int64
}

// Update album title/artist
func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbum, arg.ArtistID, arg.Title, arg.ID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAlbumImagePath = `-- name: UpdateAlbumImagePath :one
UPDATE albums
SET image_path = COALESCE(?, image_path)
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpdateAlbumImagePathParams struct {
	ImagePath dbtypes.NullString
	ID        int64
}

// Update album image path (only if currently NULL)
func (q *Queries) UpdateAlbumImagePath(ctx context.Context, arg UpdateAlbumImagePathParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbumImagePath, arg.ImagePath, arg.ID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAlbum = `-- name: UpsertAlbum :one
INSERT INTO albums (artist_id, title)
VALUES (?, ?)
ON CONFLICT(artist_id, title) DO UPDATE SET
  artist_id = excluded.artist_id,
  title = excluded.title,
  deleted_at = NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpsertAlbumParams struct {
	ArtistID int64
	Title    string
}

// Upsert album by artist/title (revives soft-deleted)
func (q *Queries) UpsertAlbum(ctx context.Context, arg UpsertAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, upsertAlbum, arg.ArtistID, arg.Title)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
