// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: albums.sql

package db

import (
	"context"

	dbtypes "bottomley.ian/musicserver/internal/dbtypes"
)

const getAlbumByID = `-- name: GetAlbumByID :one
SELECT id, artist_id, title, image_path, deleted_at, created_at, updated_at
FROM albums
WHERE id = ?
  AND deleted_at IS NULL
`

// Get a single album by ID (excluding soft-deleted)
func (q *Queries) GetAlbumByID(ctx context.Context, id int64) (Album, error) {
	row := q.db.QueryRowContext(ctx, getAlbumByID, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAlbums = `-- name: ListAlbums :many
SELECT id, artist_id, title, image_path, deleted_at, created_at, updated_at
FROM albums
WHERE deleted_at IS NULL
ORDER BY title
`

// List albums
func (q *Queries) ListAlbums(ctx context.Context) ([]Album, error) {
	rows, err := q.db.QueryContext(ctx, listAlbums)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Album
	for rows.Next() {
		var i Album
		if err := rows.Scan(
			&i.ID,
			&i.ArtistID,
			&i.Title,
			&i.ImagePath,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteAlbum = `-- name: SoftDeleteAlbum :one
UPDATE albums
SET deleted_at = CURRENT_TIMESTAMP
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

// Soft delete album
func (q *Queries) SoftDeleteAlbum(ctx context.Context, id int64) (Album, error) {
	row := q.db.QueryRowContext(ctx, softDeleteAlbum, id)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAlbum = `-- name: UpdateAlbum :one
UPDATE albums
SET artist_id = ?, title = ?
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpdateAlbumParams struct {
	ArtistID int64
	Title    string
	ID       int64
}

// Update album title/artist
func (q *Queries) UpdateAlbum(ctx context.Context, arg UpdateAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbum, arg.ArtistID, arg.Title, arg.ID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAlbumImagePath = `-- name: UpdateAlbumImagePath :one
UPDATE albums
SET image_path = COALESCE(?, image_path)
WHERE id = ?
  AND deleted_at IS NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpdateAlbumImagePathParams struct {
	ImagePath dbtypes.NullString
	ID        int64
}

// Update album image path (only if currently NULL)
func (q *Queries) UpdateAlbumImagePath(ctx context.Context, arg UpdateAlbumImagePathParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, updateAlbumImagePath, arg.ImagePath, arg.ID)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAlbum = `-- name: UpsertAlbum :one
INSERT INTO albums (artist_id, title)
VALUES (?, ?)
ON CONFLICT(artist_id, title) DO UPDATE SET
  artist_id = excluded.artist_id,
  title = excluded.title,
  deleted_at = NULL
RETURNING id, artist_id, title, image_path, deleted_at, created_at, updated_at
`

type UpsertAlbumParams struct {
	ArtistID int64
	Title    string
}

// Upsert album by artist/title (revives soft-deleted)
func (q *Queries) UpsertAlbum(ctx context.Context, arg UpsertAlbumParams) (Album, error) {
	row := q.db.QueryRowContext(ctx, upsertAlbum, arg.ArtistID, arg.Title)
	var i Album
	err := row.Scan(
		&i.ID,
		&i.ArtistID,
		&i.Title,
		&i.ImagePath,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
