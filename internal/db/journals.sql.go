// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: journals.sql

package db

import (
	"context"
)

const getJournalByDate = `-- name: GetJournalByDate :one
SELECT year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
FROM journals
WHERE year = ?
  AND month = ?
  AND day = ?
`

type GetJournalByDateParams struct {
	Year  int64
	Month int64
	Day   int64
}

// Get journal by date
func (q *Queries) GetJournalByDate(ctx context.Context, arg GetJournalByDateParams) (Journal, error) {
	row := q.db.QueryRowContext(ctx, getJournalByDate, arg.Year, arg.Month, arg.Day)
	var i Journal
	err := row.Scan(
		&i.Year,
		&i.Month,
		&i.Day,
		&i.SizeBytes,
		&i.Hash,
		&i.Tags,
		&i.LastCheckedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJournalsByMonth = `-- name: ListJournalsByMonth :many
SELECT year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
FROM journals
WHERE year = ?
  AND month = ?
ORDER BY day
`

type ListJournalsByMonthParams struct {
	Year  int64
	Month int64
}

// List journals for a month
func (q *Queries) ListJournalsByMonth(ctx context.Context, arg ListJournalsByMonthParams) ([]Journal, error) {
	rows, err := q.db.QueryContext(ctx, listJournalsByMonth, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Journal
	for rows.Next() {
		var i Journal
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.Day,
			&i.SizeBytes,
			&i.Hash,
			&i.Tags,
			&i.LastCheckedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJournalLastChecked = `-- name: UpdateJournalLastChecked :exec
UPDATE journals
SET last_checked_at = CURRENT_TIMESTAMP
WHERE year = ?
  AND month = ?
  AND day = ?
`

type UpdateJournalLastCheckedParams struct {
	Year  int64
	Month int64
	Day   int64
}

// Update journal last checked timestamp
func (q *Queries) UpdateJournalLastChecked(ctx context.Context, arg UpdateJournalLastCheckedParams) error {
	_, err := q.db.ExecContext(ctx, updateJournalLastChecked, arg.Year, arg.Month, arg.Day)
	return err
}

const upsertJournal = `-- name: UpsertJournal :one
INSERT INTO journals (year, month, day, size_bytes, hash, tags, last_checked_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(year, month, day) DO UPDATE SET
  size_bytes = excluded.size_bytes,
  hash = excluded.hash,
  tags = excluded.tags,
  last_checked_at = CURRENT_TIMESTAMP
RETURNING year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
`

type UpsertJournalParams struct {
	Year      int64
	Month     int64
	Day       int64
	SizeBytes int64
	Hash      string
	Tags      string
}

// Upsert journal metadata
func (q *Queries) UpsertJournal(ctx context.Context, arg UpsertJournalParams) (Journal, error) {
	row := q.db.QueryRowContext(ctx, upsertJournal,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.SizeBytes,
		arg.Hash,
		arg.Tags,
	)
	var i Journal
	err := row.Scan(
		&i.Year,
		&i.Month,
		&i.Day,
		&i.SizeBytes,
		&i.Hash,
		&i.Tags,
		&i.LastCheckedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
