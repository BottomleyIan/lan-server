// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: journals.sql

package db

import (
	"context"
)

const deleteJournalsByMonth = `-- name: DeleteJournalsByMonth :exec
DELETE FROM journals
WHERE year = ?
  AND month = ?
`

type DeleteJournalsByMonthParams struct {
	Year  int64
	Month int64
}

// Delete journals for a month
func (q *Queries) DeleteJournalsByMonth(ctx context.Context, arg DeleteJournalsByMonthParams) error {
	_, err := q.db.ExecContext(ctx, deleteJournalsByMonth, arg.Year, arg.Month)
	return err
}

const getJournalByDate = `-- name: GetJournalByDate :one
SELECT year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
FROM journals
WHERE year = ?
  AND month = ?
  AND day = ?
`

type GetJournalByDateParams struct {
	Year  int64
	Month int64
	Day   int64
}

// Get journal by date
func (q *Queries) GetJournalByDate(ctx context.Context, arg GetJournalByDateParams) (Journal, error) {
	row := q.db.QueryRowContext(ctx, getJournalByDate, arg.Year, arg.Month, arg.Day)
	var i Journal
	err := row.Scan(
		&i.Year,
		&i.Month,
		&i.Day,
		&i.SizeBytes,
		&i.Hash,
		&i.Tags,
		&i.LastCheckedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJournalTags = `-- name: ListJournalTags :many
SELECT tags
FROM journals
`

// List all journal tags (raw JSON per journal)
func (q *Queries) ListJournalTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listJournalTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tags string
		if err := rows.Scan(&tags); err != nil {
			return nil, err
		}
		items = append(items, tags)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJournalsByMonth = `-- name: ListJournalsByMonth :many
SELECT year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
FROM journals
WHERE year = ?
  AND month = ?
ORDER BY day
`

type ListJournalsByMonthParams struct {
	Year  int64
	Month int64
}

// List journals for a month
func (q *Queries) ListJournalsByMonth(ctx context.Context, arg ListJournalsByMonthParams) ([]Journal, error) {
	rows, err := q.db.QueryContext(ctx, listJournalsByMonth, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Journal
	for rows.Next() {
		var i Journal
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.Day,
			&i.SizeBytes,
			&i.Hash,
			&i.Tags,
			&i.LastCheckedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listJournalsFiltered = `-- name: ListJournalsFiltered :many
SELECT year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
FROM journals
WHERE (?1 IS NULL OR year = ?1)
  AND (?2 IS NULL OR month = ?2)
  AND (?3 IS NULL OR day = ?3)
  AND (
    ?4 IS NULL
    OR EXISTS (
      SELECT 1
      FROM json_each(journals.tags)
      WHERE value = ?4
    )
  )
ORDER BY year DESC, month DESC, day DESC
`

type ListJournalsFilteredParams struct {
	Column1 interface{}
	Column2 interface{}
	Column3 interface{}
	Column4 interface{}
}

// List journals with optional filters
func (q *Queries) ListJournalsFiltered(ctx context.Context, arg ListJournalsFilteredParams) ([]Journal, error) {
	rows, err := q.db.QueryContext(ctx, listJournalsFiltered,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Journal
	for rows.Next() {
		var i Journal
		if err := rows.Scan(
			&i.Year,
			&i.Month,
			&i.Day,
			&i.SizeBytes,
			&i.Hash,
			&i.Tags,
			&i.LastCheckedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJournalLastChecked = `-- name: UpdateJournalLastChecked :exec
UPDATE journals
SET last_checked_at = CURRENT_TIMESTAMP
WHERE year = ?
  AND month = ?
  AND day = ?
`

type UpdateJournalLastCheckedParams struct {
	Year  int64
	Month int64
	Day   int64
}

// Update journal last checked timestamp
func (q *Queries) UpdateJournalLastChecked(ctx context.Context, arg UpdateJournalLastCheckedParams) error {
	_, err := q.db.ExecContext(ctx, updateJournalLastChecked, arg.Year, arg.Month, arg.Day)
	return err
}

const upsertJournal = `-- name: UpsertJournal :one
INSERT INTO journals (year, month, day, size_bytes, hash, tags, last_checked_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(year, month, day) DO UPDATE SET
  size_bytes = excluded.size_bytes,
  hash = excluded.hash,
  tags = excluded.tags,
  last_checked_at = CURRENT_TIMESTAMP
RETURNING year, month, day, size_bytes, hash, tags, last_checked_at, created_at, updated_at
`

type UpsertJournalParams struct {
	Year      int64
	Month     int64
	Day       int64
	SizeBytes int64
	Hash      string
	Tags      string
}

// Upsert journal metadata
func (q *Queries) UpsertJournal(ctx context.Context, arg UpsertJournalParams) (Journal, error) {
	row := q.db.QueryRowContext(ctx, upsertJournal,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.SizeBytes,
		arg.Hash,
		arg.Tags,
	)
	var i Journal
	err := row.Scan(
		&i.Year,
		&i.Month,
		&i.Day,
		&i.SizeBytes,
		&i.Hash,
		&i.Tags,
		&i.LastCheckedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
